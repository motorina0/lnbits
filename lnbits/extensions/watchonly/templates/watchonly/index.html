{% extends "base.html" %} {% from "macros.jinja" import window_vars with context
%} {% block page %}
<div class="row q-col-gutter-md">
  <div class="col-12 col-md-7 q-gutter-y-md">
    <q-card>
      <q-card-section>
        {% raw %}
        <q-btn unelevated color="primary" @click="formDialog.show = true"
          >New wallet
        </q-btn>
        <q-btn unelevated color="primary" icon="edit">
          <div class="cursor-pointer">
            <q-tooltip> Point to another Mempool </q-tooltip>
            {{ this.mempool.endpoint }}
            <q-popup-edit v-model="mempool.endpoint">
              <q-input color="accent" v-model="mempool.endpoint"> </q-input>
              <center>
                <q-btn flat dense @click="updateMempool()" v-close-popup
                  >set</q-btn
                >
                <q-btn flat dense v-close-popup>cancel</q-btn>
              </center>
            </q-popup-edit>
          </div>
        </q-btn>
      </q-card-section>
    </q-card>

    <q-card>
      <q-card-section>
        <div class="row items-center no-wrap q-mb-md">
          <div class="col">
            <h5 class="text-subtitle1 q-my-none">Wallets</h5>
          </div>
          <div class="col-auto">
            <q-input
              borderless
              dense
              debounce="300"
              v-model="filter"
              placeholder="Search"
            >
              <template v-slot:append>
                <q-icon name="search"></q-icon>
              </template>
            </q-input>
          </div>
        </div>
        <q-table
          flat
          dense
          :data="walletLinks"
          row-key="id"
          :columns="WalletsTable.columns"
          :pagination.sync="WalletsTable.pagination"
          :filter="filter"
        >
          <template v-slot:header="props">
            <q-tr :props="props">
              <q-th auto-width></q-th>
              <q-th
                v-for="col in props.cols"
                :key="col.name"
                :props="props"
                auto-width
              >
                {{ col.label }}
              </q-th>
              <q-th auto-width></q-th>
            </q-tr>
          </template>
          <template v-slot:body="props">
            <q-tr :props="props">
              <q-td auto-width>
                <q-btn
                  unelevated
                  dense
                  size="xs"
                  icon="dns"
                  :color="($q.dark.isActive) ? 'grey-7' : 'grey-5'"
                  @click="openQrCodeDialog(props.row.id)"
                >
                  <q-tooltip> Addresses </q-tooltip>
                </q-btn>
                <q-btn
                  flat
                  dense
                  size="xs"
                  @click="deleteWalletLink(props.row.id)"
                  icon="cancel"
                  color="pink"
                ></q-btn>
              </q-td>
              <q-td
                v-for="col in props.cols"
                :key="col.name"
                :props="props"
                auto-width
              >
                {{ col.value }}
              </q-td>
            </q-tr>
          </template>
        </q-table>
      </q-card-section>
    </q-card>

    <q-card>
      <div class="row items-center no-wrap q-mb-md">
        <div class="col q-ml-lg">
          <q-btn
            unelevated
            color="primary"
            @click="scanAllAddressUTXOs"
            :disabled="scan.scanning == true"
            >Scan Blockchain</q-btn
          >
          <q-spinner
            v-if="scan.scanning == true"
            color="primary"
            size="2.55em"
          ></q-spinner>
        </div>
        <div class="col">
          <div class="row justify-center q-gutter-x-md items-center">
            <div class="text-h3 q-pa-sm">{{satBtc(utxos.total)}}</div>
            <q-btn flat @click="utxos.sats = !utxos.sats">
              {{utxos.sats ? ' sats' : ' BTC'}}</q-btn
            >
          </div>
        </div>
      </div>
      <div v-if="scan.scanning == true">
        <!-- todo: make height smaller -->
        <q-linear-progress
          :value="scan.scanIndex / scan.scanCount"
          size="10px"
          color="primary"
          class="q-mt-sm"
        ></q-linear-progress>
      </div>
    </q-card>

    <q-card>
      <q-card-section>
        <q-tabs v-model="tab" no-caps class="bg-dark text-white shadow-2">
          <q-tab name="coins" label="Coins"></q-tab>
          <q-tab name="history" label="History"></q-tab>
          <q-tab name="addresses" label="Addresses"></q-tab>
        </q-tabs>
        <q-tab-panels v-model="tab">
          <!-- todo: why blak bacground? -->
          <q-tab-panel name="coins">
            <div class="row items-center no-wrap q-mb-md">
              <div class="col">
                <h5 class="text-subtitle1 q-my-none">UTXOs</h5>
              </div>
              <div class="col-auto">
                <q-input
                  borderless
                  dense
                  debounce="300"
                  v-model="TxosTable.filter"
                  placeholder="Search"
                >
                  <template v-slot:append>
                    <q-icon name="search"></q-icon>
                  </template>
                </q-input>
              </div>
            </div>
            <q-table
              flat
              dense
              :data="utxos.data"
              row-key="txid"
              :columns="TxosTable.columns"
              :pagination.sync="TxosTable.pagination"
              :filter="TxosTable.filter"
            >
              <template v-slot:header="props">
                <q-tr :props="props">
                  <q-th
                    v-for="col in props.cols"
                    :key="col.name"
                    :props="props"
                    auto-width
                  >
                    {{ col.label }}
                  </q-th>
                  <q-th auto-width></q-th>
                </q-tr>
              </template>
              <template v-slot:body="props">
                <q-tr :props="props">
                  <q-td
                    v-for="col in props.cols"
                    :key="col.name"
                    :props="props"
                    auto-width
                    :class="col.value == true ? 'text-green-13 text-weight-bold' : ''"
                  >
                    {{ col.name == 'value' ? satBtc(col.value) : col.value }}
                  </q-td>
                </q-tr>
              </template>
            </q-table>
          </q-tab-panel>
          <q-tab-panel name="history">
            <h3>H</h3>
          </q-tab-panel>
          <q-tab-panel name="addresses">
            <h3>A</h3>
          </q-tab-panel>
        </q-tab-panels>
      </q-card-section>
    </q-card>
  </div>

  {% endraw %}

  <div class="col-12 col-md-5 q-gutter-y-md">
    <q-card>
      <q-card-section>
        <h6 class="text-subtitle1 q-my-none">
          {{SITE_TITLE}} Watch Only Extension
        </h6>
      </q-card-section>
      <q-card-section class="q-pa-none">
        <q-separator></q-separator>
        <q-list> {% include "watchonly/_api_docs.html" %} </q-list>
      </q-card-section>
    </q-card>
  </div>

  <q-dialog v-model="formDialog.show" position="top" @hide="closeFormDialog">
    <q-card class="q-pa-lg q-pt-xl lnbits__dialog-card">
      <q-form @submit="sendFormData" class="q-gutter-md">
        <q-input
          filled
          dense
          v-model.trim="formDialog.data.title"
          type="text"
          label="Title"
        ></q-input>

        <q-input
          filled
          type="textarea"
          v-model="formDialog.data.masterpub"
          height="50px"
          autogrow
          label="Account Extended Public Key; xpub, ypub, zpub; Bitcoin Descriptor"
        ></q-input>

        <div class="row q-mt-lg">
          <q-btn
            unelevated
            color="primary"
            :disable="
                formDialog.data.masterpub == null ||
                formDialog.data.title == null"
            type="submit"
            >Create Watch-only Wallet</q-btn
          >
          <q-btn v-close-popup flat color="grey" class="q-ml-auto"
            >Cancel</q-btn
          >
        </div>
      </q-form>
    </q-card>
  </q-dialog>

  <q-dialog v-model="addresses.show" position="top">
    <q-card v-if="addresses.data" class="q-pa-lg lnbits__dialog-card">
      {% raw %}
      <h5 class="text-subtitle1 q-my-none">Addresses</h5>
      <q-separator></q-separator><br />
      <p>
        <strong>Current:</strong>
        {{ currentaddress }}
        <q-btn
          flat
          dense
          size="ms"
          icon="visibility"
          type="a"
          :href="mempool.endpoint + '/address/' + currentaddress"
          target="_blank"
        ></q-btn>
      </p>
      <q-responsive :ratio="1" class="q-mx-xl q-mb-md">
        <qrcode
          :value="currentaddress"
          :options="{width: 800}"
          class="rounded-borders"
        ></qrcode>
      </q-responsive>
      <p style="word-break: break-all">
        <q-scroll-area style="height: 200px; max-width: 100%">
          <q-list bordered v-for="data in addresses.data.slice().reverse()">
            <q-item>
              <q-item-section>{{ data.address }}</q-item-section>
              <q-btn
                flat
                dense
                size="ms"
                icon="visibility"
                type="a"
                :href="mempool.endpoint + '/address/' + data.address"
                target="_blank"
              ></q-btn>
            </q-item>
          </q-list>
        </q-scroll-area>
      </p>

      <div class="row q-mt-lg q-gutter-sm">
        <q-btn
          outline
          color="grey"
          @click="getFreshAddress(current)"
          class="q-ml-sm"
          >Get fresh address</q-btn
        >
        <q-btn v-close-popup flat color="grey" class="q-ml-auto">Close</q-btn>
      </div>
    </q-card>
  </q-dialog>
  {% endraw %}
</div>
{% endblock %} {% block scripts %} {{ window_vars(user) }}
<script type="text/javascript" src="https://mempool.space/mempool.js"></script>
<style></style>
<script>
  const sleep = ms => new Promise(r => setTimeout(r, ms))

  Vue.component(VueQrcode.name, VueQrcode)

  Vue.filter('reverse', function (value) {
    // slice to make a copy of array, then reverse the copy
    return value.slice().reverse()
  })
  var locationPath = [
    window.location.protocol,
    '//',
    window.location.hostname,
    window.location.pathname
  ].join('')

  var mapWalletLink = function (obj) {
    obj._data = _.clone(obj)
    obj.date = obj.time
      ? Quasar.utils.date.formatDate(
          new Date(obj.time * 1000),
          'YYYY-MM-DD HH:mm'
        )
      : ''
    return obj
  }
  var mapAddresses = function (obj) {
    obj._data = _.clone(obj)
    obj.date = obj.time
      ? Quasar.utils.date.formatDate(
          new Date(obj.time * 1000),
          'YYYY-MM-DD HH:mm'
        )
      : ''
    return obj
  }

  new Vue({
    el: '#vue',
    mixins: [windowMixin],
    data: function () {
      return {
        filter: '',
        balance: null,
        checker: null, // todo: remove?
        scan: {
          scanning: false,
          scanCount: 0,
          scanIndex: 0
        },

        walletLinks: [],
        currentaddress: '34dq7v1SbXHBuF688EZGJK3gJav1bcURkR', // todo: fix init
        tab: 'coins',
        addresses: {
          // todo: lower-case
          show: false,
          data: []
        },
        utxos: {
          data: [],
          total: 0,
          sats: true
        },
        mempool: {
          endpoint: ''
        },
        WalletsTable: {
          columns: [
            {name: 'id', align: 'left', label: 'ID', field: 'id'},
            {
              name: 'title',
              align: 'left',
              label: 'Title',
              field: 'title'
            },
            {
              name: 'masterpub',
              align: 'left',
              label: 'MasterPub',
              field: 'masterpub'
            }
          ],
          pagination: {
            rowsPerPage: 10
          }
        },
        TxosTable: {
          columns: [
            {
              name: 'confirmed',
              align: 'center',
              label: 'Confirmed',
              field: 'confirmed',
              sortable: true
            },
            {
              name: 'address',
              align: 'left',
              label: 'Address',
              field: 'address',
              sortable: true
            },
            {
              name: 'value',
              align: 'left',
              label: 'Value',
              field: 'value',
              sortable: true
            },
            {
              name: 'date',
              align: 'left',
              label: 'Date',
              field: 'date',
              sortable: true
            },
            {
              name: 'txid',
              align: 'left',
              label: 'TX ID',
              field: 'txid',
              sortable: true
            }
          ],
          pagination: {
            rowsPerPage: 10
          },
          uxtosFilter: ''
        },

        formDialog: {
          show: false,
          data: {}
        },

        qrCodeDialog: {
          show: false,
          data: null
        }
      }
    },

    methods: {
      getAddressDetails: function (address) {
        LNbits.api
          .request(
            'GET',
            '/watchonly/api/v1/mempool/' + address,
            this.g.user.wallets[0].inkey
          )
          .then(function (response) {
            return reponse.data
          })
          .catch(function (error) {
            LNbits.utils.notifyApiError(error)
          })
      },
      refreshAddresses: async function () {
        const wallets = await this.getWatchOnlyWallets()
        this.addresses.data = []
        for (const {id, address_no} of wallets) {
          const addrs = await this.getAddressesForWallet(id)
          this.addresses.data.push(...addrs)
        }
      },
      getAddressesForWallet: async function (walletId) {
        try {
          const {data} = await LNbits.api.request(
            'GET',
            '/watchonly/api/v1/addresses/' + walletId,
            this.g.user.wallets[0].inkey
          )
          return data
        } catch (err) {
          LNbits.utils.notifyApiError(err)
        }
      },
      updateAmountForAddress: async function (addressId, amount = 0) {
        try {
          const wallet = this.g.user.wallets[0] // todo: find active wallet
          const {data} = await LNbits.api.request(
            'PUT',
            `/watchonly/api/v1/address/${addressId}`,
            wallet.adminkey,
            {amount}
          )
          console.log('### updateAmountForAddress', data)
        } catch (err) {
          LNbits.utils.notifyApiError(err)
        }
      },
      getFreshAddress: function (walletId) {
        var self = this

        LNbits.api
          .request(
            'GET',
            '/watchonly/api/v1/address/' + walletId,
            this.g.user.wallets[0].inkey
          )
          .then(function (response) {
            self.addresses.data = response.data
            self.currentaddress =
              self.addresses.data[self.addresses.data.length - 1].address
          })
      },
      getMempool: function () {
        var self = this

        LNbits.api
          .request(
            'GET',
            '/watchonly/api/v1/mempool',
            this.g.user.wallets[0].adminkey
          )
          .then(function (response) {
            self.mempool.endpoint = response.data.endpoint
          })
          .catch(function (error) {
            LNbits.utils.notifyApiError(error)
          })
      },

      updateMempool: function () {
        var self = this
        var wallet = this.g.user.wallets[0]
        LNbits.api
          .request(
            'PUT',
            '/watchonly/api/v1/mempool',
            wallet.adminkey,
            self.mempool
          )
          .then(function (response) {
            self.mempool.endpoint = response.data.endpoint
            self.walletLinks.push(mapwalletLink(response.data))
          })
          .catch(function (error) {
            LNbits.utils.notifyApiError(error)
          })
      },
      getAddressTxsUtxoDelayed: async function (address, retryCount = 0) {
        const {
          bitcoin: {addresses: addressesAPI}
        } = mempoolJS()
        try {
          console.log('### IN mempool call', address)
          await sleep(50)
          return await addressesAPI.getAddressTxsUtxo({
            address
          })
        } catch (err) {
          if (retryCount > 10) throw err
          console.log('### ERR mempool call', (retryCount + 1) * 500, address)
          await sleep((retryCount + 1) * 1000)
          return this.getAddressTxsUtxoDelayed(address, retryCount + 1)
        }
      },
      updateUtxosForAddress: function (addressData, utxos = []) {
        utxos.forEach(utxo => {
          this.utxos.data.push({
            txid: utxo.txid,
            address: addressData.address,
            confirmed: utxo.status.confirmed,
            value: utxo.value,
            date:
              utxo.status?.block_time &&
              moment(utxo.status?.block_time * 1000).format('LLL'),
            sort: utxo.status?.block_time
          })
        })
        if (utxos.length) {
          this.utxos.data.sort((a, b) => b.sort - a.sort)
          this.utxos.total = this.utxos.data.reduce(
            (total, y) => (total += y?.value || 0),
            0
          )
        }
        const addressTotal = utxos.reduce(
          (total, y) => (total += y?.value || 0),
          0
        )
        this.updateAmountForAddress(addressData.id, addressTotal)
      },
      scanAllAddressUTXOs: async function () {
        await this.refreshAddresses()
        let addresses = this.addresses.data
        this.utxos.data = []
        // Loop while new funds are found on the gap adresses.
        // Use 1000 limit as a safety check (scan 20 000 addresses max)
        for (let i = 0; i < 1000 && addresses.length; i++) {
          await this.updateUtxosForAddresses(addresses)
          const oldAddresses = this.addresses.data.slice(0)
          await this.refreshAddresses()
          const newAddresses = this.addresses.data.slice(0)
          // check if gap addresses have been extended
          addresses = newAddresses.filter(
            newAddr => !oldAddresses.find(oldAddr => oldAddr.id === newAddr.id)
          )
          if (addresses.length) {
            this.$q.notify({
              type: 'positive',
              message: 'Funds found! Scanning for more...',
              timeout: 5000
            })
          }
        }
      },
      scanAddressWithAmountUTXOs: async function () {
        const addresses = this.addresses.data.filter(a => a.amount)
        this.utxos.data = []
        await this.updateUtxosForAddresses(addresses)
      },
      updateUtxosForAddresses: async function (addresses = []) {
        this.scan = {scanning: true, scanCount: addresses.length, scanIndex: 0}

        try {
          for (addrData of addresses) {
            const utxos = await this.getAddressTxsUtxoDelayed(addrData.address)
            this.updateUtxosForAddress(addrData, utxos)
            this.scan.scanIndex++
          }
        } catch (err) {
          console.error(err) // todo: show UI error
        } finally {
          this.scan.scanning = false
        }
      },

      getWatchOnlyWallets: async function () {
        const {data} = await LNbits.api.request(
          'GET',
          '/watchonly/api/v1/wallet',
          this.g.user.wallets[0].inkey
        )
        return data
      },
      refreshWalletLinks: async function () {
        try {
          const wallets = await this.getWatchOnlyWallets()
          this.walletLinks = wallets.map(obj => {
            this.getAddressesForWallet(obj.id)
            return mapWalletLink(obj)
          })
        } catch (err) {
          console.log('### err', err)
          LNbits.utils.notifyApiError(err)
        }
      },

      closeFormDialog: function () {
        this.formDialog.data = {
          is_unique: false
        }
      },
      openQrCodeDialog: function (linkId) {
        var self = this
        this.getAddressesForWallet(linkId)
        self.current = linkId
        self.addresses.show = true
      },
      sendFormData: function () {
        var wallet = this.g.user.wallets[0]
        var data = _.omit(this.formDialog.data, 'wallet')
        this.createWalletLink(wallet, data)
      },
      createWalletLink: function (wallet, data) {
        var self = this

        LNbits.api
          .request('POST', '/watchonly/api/v1/wallet', wallet.adminkey, data)
          .then(function (response) {
            self.walletLinks.push(mapWalletLink(response.data))
            self.formDialog.show = false
          })
          .catch(function (error) {
            LNbits.utils.notifyApiError(error)
          })
      },
      deleteWalletLink: function (linkId) {
        var self = this
        var link = _.findWhere(this.walletLinks, {id: linkId})
        LNbits.utils
          .confirmDialog(
            'Are you sure you want to delete this watch only wallet?'
          )
          .onOk(async () => {
            try {
              await LNbits.api.request(
                'DELETE',
                '/watchonly/api/v1/wallet/' + linkId,
                this.g.user.wallets[0].adminkey
              )
              this.walletLinks = _.reject(this.walletLinks, function (obj) {
                return obj.id === linkId
              })
              await this.refreshAddresses()
              await this.scanAddressWithAmountUTXOs()
            } catch (err) {
              LNbits.utils.notifyApiError(error)
            }
          })
      },
      exportCSV: function () {
        LNbits.utils.exportCSV(this.paywallsTable.columns, this.paywalls)
      },
      satBtc(val) {
        return this.utxos.sats
          ? LNbits.utils.formatSat(val)
          : val == 0
          ? 0.0
          : (val / 100000000).toFixed(8)
      }
    },
    created: async function () {
      if (this.g.user.wallets.length) {
        this.getMempool()
        await this.refreshAddresses()
        await this.scanAddressWithAmountUTXOs()
        this.refreshWalletLinks()
      }
    }
  })
</script>
{% endblock %}
