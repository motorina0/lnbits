{% extends "base.html" %} {% from "macros.jinja" import window_vars with context
%} {% block page %}
<div class="row q-col-gutter-md">
  <div class="col-12 col-md-7 q-gutter-y-md">
    <q-card>
      <q-card-section>
        {% raw %}
        <q-btn unelevated color="primary" @click="formDialog.show = true"
          >Add Wallet Account
        </q-btn>
        <q-btn unelevated color="primary" icon="edit">
          <div class="cursor-pointer">
            <q-tooltip> Point to another Mempool </q-tooltip>
            {{ this.mempool.endpoint }}
            <q-popup-edit v-model="mempool.endpoint">
              <q-input color="accent" v-model="mempool.endpoint"> </q-input>
              <center>
                <q-btn flat dense @click="updateMempool()" v-close-popup
                  >set</q-btn
                >
                <q-btn flat dense v-close-popup>cancel</q-btn>
              </center>
            </q-popup-edit>
          </div>
        </q-btn>
      </q-card-section>
    </q-card>

    <q-card>
      <q-card-section>
        <div class="row items-center no-wrap q-mb-md">
          <div class="col">
            <h5 class="text-subtitle1 q-my-none">Wallet Accounts</h5>
          </div>
          <div class="col-auto">
            <q-input
              borderless
              dense
              debounce="300"
              v-model="filter"
              placeholder="Search"
            >
              <template v-slot:append>
                <q-icon name="search"></q-icon>
              </template>
            </q-input>
          </div>
        </div>
        <q-table
          flat
          dense
          :data="walletLinks"
          row-key="id"
          :columns="WalletsTable.columns"
          :pagination.sync="WalletsTable.pagination"
          :filter="filter"
        >
          <template v-slot:header="props">
            <q-tr :props="props">
              <q-th auto-width></q-th>
              <q-th
                v-for="col in props.cols"
                :key="col.name"
                :props="props"
                auto-width
              >
                {{ col.label }}
              </q-th>
              <q-th auto-width></q-th>
            </q-tr>
          </template>
          <template v-slot:body="props">
            <q-tr :props="props">
              <q-td auto-width>
                <q-btn
                  flat
                  dense
                  size="xs"
                  @click="deleteWalletLink(props.row.id)"
                  icon="cancel"
                  color="pink"
                ></q-btn>
                <q-badge
                  color="secondary"
                  class="q-mr-md cursor-pointer"
                  @click="openGetFreshAddressDialog(props.row.id)"
                >
                  New Receive Address
                </q-badge>
              </q-td>
              <q-td
                v-for="col in props.cols"
                :key="col.name"
                :props="props"
                auto-width
              >
                {{ col.value }}
              </q-td>
            </q-tr>
          </template>
        </q-table>
      </q-card-section>
    </q-card>

    <q-card>
      <div class="row items-center no-wrap q-mb-md">
        <div class="col q-ml-lg">
          <q-btn
            unelevated
            color="secondary"
            @click="scanAllAddressUTXOs"
            :disabled="scan.scanning == true"
            >Scan Blockchain</q-btn
          >
          <q-spinner
            v-if="scan.scanning == true"
            color="primary"
            size="2.55em"
          ></q-spinner>
        </div>
        <div class="col">
          <div class="row justify-center q-gutter-x-md items-center">
            <div class="text-h3 q-pa-sm">{{satBtc(utxos.total)}}</div>
            <q-btn flat @click="utxos.sats = !utxos.sats">
              {{utxos.sats ? ' sats' : ' BTC'}}</q-btn
            >
          </div>
        </div>
      </div>
      <div v-if="scan.scanning == true">
        <!-- todo: make height smaller -->
        <q-linear-progress
          :value="scan.scanIndex / scan.scanCount"
          size="10px"
          color="primary"
          class="q-mt-sm"
        ></q-linear-progress>
      </div>
    </q-card>

    <q-card>
      <q-card-section>
        <q-tabs v-model="tab" no-caps class="bg-dark text-white shadow-2">
          <q-tab name="addresses" label="Addresses"></q-tab>
          <q-tab name="history" label="History"></q-tab>
          <q-tab name="coins" label="Coins"></q-tab>
        </q-tabs>
        <q-tab-panels v-model="tab">
          <!-- todo: why blak bacground? -->

          <q-tab-panel name="addresses">
            <div class="row items-center no-wrap q-mb-md">
              <div class="col q-pr-lg">
                <q-select
                  filled
                  clearable
                  dense
                  emit-value
                  v-model="addresses.selectedWallet"
                  :options="walletLinks"
                  label="Wallet Account"
                ></q-select>
              </div>
              <div class="col q-pr-lg">
                <q-select
                  filled
                  clearable
                  dense
                  emit-value
                  multiple
                  :options="addresses.filterOptions"
                  v-model="addresses.filterValues"
                  :options="walletLinks"
                  label="Filter"
                ></q-select>
              </div>
              <div class="col-auto">
                <q-input
                  borderless
                  dense
                  debounce="300"
                  v-model="AddressesTable.filter"
                  placeholder="Search"
                >
                  <template v-slot:append>
                    <q-icon name="search"></q-icon>
                  </template>
                </q-input>
              </div>
            </div>
            <q-table
              style="height: 400px"
              flat
              dense
              :data="getFilteredAddresses()"
              row-key="id"
              virtual-scroll
              :columns="AddressesTable.columns"
              :pagination.sync="AddressesTable.pagination"
              :filter="AddressesTable.filter"
            >
              <template v-slot:body="props">
                <q-tr :props="props">
                  <q-td auto-width>
                    <q-btn
                      size="sm"
                      color="accent"
                      round
                      dense
                      @click="props.row.expanded= !props.row.expanded"
                      :icon="props.row.expanded? 'remove' : 'add'"
                    />
                  </q-td>

                  <q-td key="address" :props="props">
                    <div>
                      {{props.row.address}}
                      <q-badge
                        v-if="props.row.branch_index === 1"
                        color="orange"
                        class="q-mr-md"
                      >
                        change
                      </q-badge>
                    </div>
                  </q-td>

                  <q-td
                    key="amount"
                    :props="props"
                    :class="props.row.amount > 0 ? 'text-green-13 text-weight-bold' : ''"
                  >
                    <div>{{satBtc(props.row.amount)}}</div>
                  </q-td>

                  <q-td key="note" :props="props" :class="">
                    <div>{{props.row.note}}</div>
                  </q-td>
                  <q-td key="wallet" :props="props" :class="">
                    <div>{{getWalletName(props.row.wallet)}}</div>
                  </q-td>
                </q-tr>
                <q-tr v-show="props.row.expanded" :props="props">
                  <q-td colspan="100%">
                    <div class="row items-center q-mb-md">
                      <div class="col-2 q-pr-lg">View Details On:</div>
                      <div class="col-10 q-pr-lg">
                        <q-btn
                          v-if="props.row.amount"
                          flat
                          dense
                          size="sm"
                          icon="launch"
                          type="a"
                          :href="mempool.endpoint + '/address/' + props.row.address"
                          target="_blank"
                          Details
                          >{{mempool.endpoint}}</q-btn
                        >
                      </div>
                    </div>
                    <div class="row items-center q-mb-md">
                      <div class="col-2 q-pr-lg">QR Code:</div>
                      <div class="col-10 q-pr-lg">
                        <q-btn
                          unelevated
                          dense
                          size="sm"
                          icon="qr_code"
                          :color="($q.dark.isActive) ? 'grey-7' : 'grey-5'"
                          @click="openQrCodeDialog(props.row)"
                        ></q-btn>
                      </div>
                    </div>
                    <div class="row items-center no-wrap q-mb-md">
                      <div class="col-2 q-pr-lg">Note:</div>
                      <div class="col-8 q-pr-lg">
                        <q-input
                          filled
                          dense
                          v-model.trim="props.row.note"
                          type="text"
                          label="Note"
                        ></q-input>
                      </div>
                      <div class="col-2 q-pr-lg">
                        <q-btn
                          outline
                          v-close-popup
                          color="grey"
                          @click="updateNoteForAddress(props.row, props.row.note)"
                          class="q-ml-sm"
                          >Update</q-btn
                        >
                      </div>
                    </div>
                    <!-- todo: link to coins -->
                  </q-td>
                </q-tr>
              </template>
            </q-table>
          </q-tab-panel>
          <q-tab-panel name="history">
            <div class="row items-center no-wrap q-mb-md">
              <div class="col q-pr-lg"></div>
              <div class="col q-pr-lg"></div>
              <div class="col-auto">
                <q-input
                  borderless
                  dense
                  debounce="300"
                  v-model="HistoryTable.filter"
                  placeholder="Search"
                >
                  <template v-slot:append>
                    <q-icon name="search"></q-icon>
                  </template>
                </q-input>
              </div>
            </div>
            <q-table
              style="height: 400px"
              flat
              dense
              :data="getFilteredAddressesHistory()"
              row-key="id"
              virtual-scroll
              :columns="HistoryTable.columns"
              :pagination.sync="HistoryTable.pagination"
              :filter="HistoryTable.filter"
            >
              <template v-slot:body="props">
                <q-tr :props="props">
                  <q-td auto-width>
                    <q-btn
                      size="sm"
                      color="accent"
                      round
                      dense
                      @click="props.row.expanded = !props.row.expanded"
                      :icon="props.row.expanded ? 'remove' : 'add'"
                    />
                  </q-td>

                  <q-td key="status" :props="props">
                    <q-badge
                      v-if="props.row.sent"
                      color="orange"
                      class="q-mr-md"
                    >
                      {{props.row.confirmed ? 'Sent' : 'Sending...'}}
                    </q-badge>
                    <q-badge
                      v-if="props.row.received"
                      color="green"
                      class="q-mr-md"
                    >
                      {{props.row.confirmed ? 'Received' : 'Receiving...'}}
                    </q-badge>
                  </q-td>
                  <q-td
                    key="amount"
                    :props="props"
                    :class="props.row.amount && props.row.received > 0 ? 'text-green-13 text-weight-bold' : ''"
                  >
                    <div>{{satBtc(props.row.amount)}}</div>
                  </q-td>
                  <q-td key="address" :props="props">
                    {{ props.row.address }}
                  </q-td>
                  <q-td key="date" :props="props"> {{ props.row.date }} </q-td>
                </q-tr>
                <q-tr v-show="props.row.expanded" :props="props">
                  <q-td colspan="100%">
                    <div class="row items-center no-wrap q-mb-md">
                      <div class="col-2 q-pr-lg">Transaction Id</div>
                      <div class="col-10 q-pr-lg">{{props.row.txId}}</div>
                    </div>
                    <div class="row items-center no-wrap q-mb-md">
                      <div class="col-2 q-pr-lg">Fee</div>
                      <div class="col-4 q-pr-lg">{{satBtc(props.row.fee)}}</div>
                    </div>
                  </q-td>
                </q-tr>
              </template>
            </q-table>
          </q-tab-panel>
          <q-tab-panel name="coins">
            <div class="row items-center no-wrap q-mb-md">
              <div class="col">UTXOs</div>
              <div class="col-auto">
                <q-input
                  borderless
                  dense
                  debounce="300"
                  v-model="UtxoTable.filter"
                  placeholder="Search"
                >
                  <template v-slot:append>
                    <q-icon name="search"></q-icon>
                  </template>
                </q-input>
              </div>
            </div>
            <q-table
              flat
              dense
              :data="utxos.data"
              row-key="id"
              :columns="UtxoTable.columns"
              :pagination.sync="UtxoTable.pagination"
              :filter="UtxoTable.filter"
            >
              <template v-slot:body="props">
                <q-tr :props="props">
                  <q-td auto-width>
                    <q-btn
                      size="sm"
                      color="accent"
                      round
                      dense
                      @click="props.row.expanded= !props.row.expanded"
                      :icon="props.row.expanded? 'remove' : 'add'"
                    />
                  </q-td>

                  <q-td key="selected" :props="props">
                    <div>
                      <q-checkbox v-model="props.row.selected"></q-checkbox>
                    </div>
                  </q-td>
                  <q-td key="status" :props="props">
                    <div>
                      <q-badge
                        v-if="props.row.confirmed"
                        color="green"
                        class="q-mr-md"
                      >
                        Confirmed
                      </q-badge>
                      <q-badge
                        v-if="!props.row.confirmed"
                        color="orange"
                        class="q-mr-md"
                      >
                        Pending
                      </q-badge>
                    </div>
                  </q-td>
                  <q-td key="address" :props="props">
                    <div>
                      {{props.row.address}}
                      <q-badge
                        v-if="props.row.isChange"
                        color="orange"
                        class="q-mr-md"
                      >
                        change
                      </q-badge>
                    </div>
                  </q-td>

                  <q-td
                    key="amount"
                    :props="props"
                    class="text-green-13 text-weight-bold"
                  >
                    <div>{{satBtc(props.row.amount)}}</div>
                  </q-td>

                  <q-td key="date" :props="props"> {{ props.row.date }} </q-td>
                  <q-td key="wallet" :props="props" :class="">
                    <div>{{getWalletName(props.row.wallet)}}</div>
                  </q-td>
                </q-tr>
                <q-tr v-show="props.row.expanded" :props="props">
                  <q-td colspan="100%">
                    <div class="row items-center q-mb-md">
                      <div class="col-2 q-pr-lg">Transaction Id</div>
                      <div class="col-10 q-pr-lg">{{ props.row.txId }}</div>
                    </div>
                  </q-td>
                </q-tr>
              </template>
              <template v-slot:bottom-row>
                <q-tr>
                  <q-td colspan="100%">
                    <div class="row items-center no-wrap q-mb-md">
                      <div class="col-9 q-pr-lg"></div>
                      <div class="col-3">Total: {{getTotalUtxoAmount()}}</div>
                    </div>
                  </q-td>
                </q-tr>
              </template>
            </q-table>

            <div class="row items-center no-wrap q-mb-md">
              <div class="col">
                <q-toggle
                  label="Make Payment"
                  color="secodary"
                  v-model="payment.show"
                  @input="initPaymentData()"
                ></q-toggle>
              </div>
            </div>
            <q-form
              v-if="payment.show"
              @submit="createTransaction"
              class="q-gutter-md"
            >
              <div class="row items-center no-wrap q-mb-md">
                <div class="col">
                  <q-table
                    flat
                    dense
                    :data="payment.data"
                    :columns="PaymentTable.columns"
                    :pagination.sync="PaymentTable.pagination"
                  >
                    <template v-slot:body="props">
                      <q-tr :props="props">
                        <div class="row no-wrap q-mb-md">
                          <div class="col-7 q-pr-lg">
                            <q-input
                              filled
                              dense
                              v-model.trim="props.row.address"
                              type="text"
                              label="Address"
                              :rules="[val => !!val || 'Field is required']"
                            ></q-input>
                          </div>
                          <div class="col-4 q-pr-lg">
                            <q-input
                              filled
                              dense
                              v-model.number="props.row.amount"
                              type="number"
                              step="1"
                              label="Amount (sats)"
                              :rules="[val => !!val || 'Field is required']"
                            ></q-input>
                          </div>
                          <div class="col-1">
                            <q-btn
                              flat
                              dense
                              size="l"
                              @click="deletePaymentAddress(props.row)"
                              icon="cancel"
                              color="pink"
                            ></q-btn>
                          </div>
                        </div>
                      </q-tr>
                    </template>
                    <template v-slot:bottom-row>
                      <q-tr>
                        <q-td colspan="100%">
                          <div class="row items-center no-wrap q-mb-md">
                            <div class="col-3 q-pr-lg">
                              <q-btn
                                unelevated
                                color="grey"
                                @click="addPaymentAddress"
                                >Add Send Address</q-btn
                              >
                            </div>
                            <div class="col-6 q-pr-lg"></div>
                            <div class="col-3">
                              Total: {{getTotalPaymentAmount()}}
                            </div>
                          </div>
                        </q-td>
                      </q-tr>
                    </template>
                  </q-table>
                </div>
              </div>
              <div class="row items-center no-wrap q-mb-md">
                <div class="col">
                  <q-toggle
                    label="Show Advanced"
                    color="secodary"
                    v-model="payment.showAdvanced"
                  ></q-toggle>
                </div>
              </div>
              <div
                v-if="payment.showAdvanced"
                class="row items-center no-wrap q-mb-md"
              >
                <div class="col-3 q-pr-lg">Send Change To Account</div>
                <div class="col-3 q-pr-lg">
                  <q-select
                    filled
                    dense
                    emit-value
                    v-model="payment.changeWallet"
                    :options="walletLinks"
                    :rules="[val => !!val || 'Field is required']"
                    label="Wallet Account"
                  ></q-select>
                </div>
                <div class="col-6 q-pl-lg">
                  <q-input
                    filled
                    dense
                    readonly
                    v-model.trim="payment.changeAddress"
                    type="text"
                    label="Change Address"
                  ></q-input>
                </div>
              </div>
              <div
                v-if="payment.showAdvanced"
                class="row items-center no-wrap q-mb-md"
              >
                <div class="col-3 q-pr-lg">Fee Rate</div>
                <div class="col-3 q-pr-lg">
                  <q-input
                    filled
                    dense
                    v-model.trim="payment.feeRate"
                    :rules="[val => !!val || 'Field is required']"
                    type="number"
                    label="sats/vbyte"
                  ></q-input>
                </div>
                <div class="col-6 q-pl-lg">
                  <!-- todo: fetch from mempool, show slider -->
                </div>
              </div>
              <div
                v-if="payment.showAdvanced"
                class="row items-center no-wrap q-mb-md"
              >
                <div class="col-3 q-pr-lg">UTXO Selection Mode</div>
                <div class="col-3 q-pr-lg">
                  <q-select
                    filled
                    dense
                    emit-value
                    v-model="payment.utxoSelectionMode"
                    :options="payment.utxoSelectionModes"
                    label="Selection Algorithm"
                  ></q-select>
                </div>
                <div class="col-6 q-pl-lg">
                  <!-- todo: fetch from mempool, show slider -->
                </div>
              </div>
              <div class="row items-center no-wrap q-mb-md">
                <div class="col-4 q-pr-lg">
                  <q-btn unelevated color="secondary" type="submit"
                    >Create PSBT</q-btn
                  >
                </div>
                <div class="col-8 q-pl-lg"></div>
              </div>
              <div
                v-if="payment.psbtBase64"
                class="row items-center no-wrap q-mb-md"
              >
                <div class="col-2 q-pr-lg">PSBT</div>
                <div class="col-10 q-pl-lg">
                  <q-input
                    v-model="payment.psbtBase64"
                    filled
                    type="textarea"
                  />
                </div>
              </div>
            </q-form>
          </q-tab-panel>
        </q-tab-panels>
      </q-card-section>
    </q-card>
  </div>

  {% endraw %}

  <div class="col-12 col-md-5 q-gutter-y-md">
    <q-card>
      <q-card-section>
        <h6 class="text-subtitle1 q-my-none">
          {{SITE_TITLE}} Watch Only Extension
        </h6>
      </q-card-section>
      <q-card-section class="q-pa-none">
        <q-separator></q-separator>
        <q-list> {% include "watchonly/_api_docs.html" %} </q-list>
      </q-card-section>
    </q-card>
  </div>

  <q-dialog v-model="formDialog.show" position="top" @hide="closeFormDialog">
    <q-card class="q-pa-lg q-pt-xl lnbits__dialog-card">
      <q-form @submit="sendFormData" class="q-gutter-md">
        <q-input
          filled
          dense
          v-model.trim="formDialog.data.title"
          type="text"
          label="Title"
        ></q-input>

        <q-input
          filled
          type="textarea"
          v-model="formDialog.data.masterpub"
          height="50px"
          autogrow
          label="Account Extended Public Key; xpub, ypub, zpub; Bitcoin Descriptor"
        ></q-input>

        <div class="row q-mt-lg">
          <q-btn
            unelevated
            color="primary"
            :disable="
                formDialog.data.masterpub == null ||
                formDialog.data.title == null"
            type="submit"
            >Add Watch-only Account</q-btn
          >
          <q-btn v-close-popup flat color="grey" class="q-ml-auto"
            >Cancel</q-btn
          >
        </div>
      </q-form>
    </q-card>
  </q-dialog>

  <q-dialog v-model="addresses.show" position="top">
    <q-card v-if="addresses.data" class="q-pa-lg lnbits__dialog-card">
      {% raw %}

      <h5 class="text-subtitle1 q-my-none">Address Details</h5>
      <q-separator></q-separator><br />

      <q-responsive :ratio="1" class="q-mx-xl q-mb-md">
        <qrcode
          v-if="currentAddress"
          :value="currentAddress.address"
          :options="{width: 800}"
          class="rounded-borders"
        ></qrcode>
      </q-responsive>
      <p v-if="currentAddress">
        {{ currentAddress.address }}
        <q-btn
          flat
          dense
          size="ms"
          icon="launch"
          type="a"
          :href="mempool.endpoint + '/address/' + currentAddress.address"
          target="_blank"
        ></q-btn>
      </p>
      <p v-if="currentAddress">
        <q-input
          filled
          dense
          v-model.trim="addresses.note"
          type="text"
          label="Note"
        ></q-input>
      </p>
      <div class="row q-mt-lg q-gutter-sm">
        <q-btn
          v-if="currentAddress"
          outline
          v-close-popup
          color="grey"
          @click="updateNoteForAddress(currentAddress, addresses.note)"
          class="q-ml-sm"
          >Update Note</q-btn
        >
        <q-btn v-close-popup flat color="grey" class="q-ml-auto">Close</q-btn>
      </div>
    </q-card>
  </q-dialog>
  {% endraw %}
</div>
{% endblock %} {% block scripts %} {{ window_vars(user) }}
<script type="text/javascript" src="https://mempool.space/mempool.js"></script>
<style></style>
<script>
  const sleep = ms => new Promise(r => setTimeout(r, ms))

  Vue.component(VueQrcode.name, VueQrcode)

  Vue.filter('reverse', function (value) {
    // slice to make a copy of array, then reverse the copy
    return value.slice().reverse()
  })
  var locationPath = [
    window.location.protocol,
    '//',
    window.location.hostname,
    window.location.pathname
  ].join('')

  var mapWalletLink = function (obj) {
    obj._data = _.clone(obj)
    obj.date = obj.time
      ? Quasar.utils.date.formatDate(
          new Date(obj.time * 1000),
          'YYYY-MM-DD HH:mm'
        )
      : ''
    const mP = obj.masterpub || ''
    obj.label = obj.title
    return obj
  }

  const blockTimeToDate = blockTime =>
    blockTime ? moment(blockTime * 1000).format('LLL') : ''

  var mapAddresses = function (obj) {
    obj._data = _.clone(obj)
    obj.date = obj.time
      ? Quasar.utils.date.formatDate(
          new Date(obj.time * 1000),
          'YYYY-MM-DD HH:mm'
        )
      : ''
    return obj
  }

  new Vue({
    el: '#vue',
    mixins: [windowMixin],
    data: function () {
      return {
        filter: '',
        balance: null,
        scan: {
          scanning: false,
          scanCount: 0,
          scanIndex: 0
        },

        walletLinks: [],

        currentAddress: null,

        tab: 'addresses',
        addresses: {
          show: false,
          data: [],
          history: [],
          selectedWallet: null,
          note: '',
          filterOptions: [
            'Show Change Addresses',
            'Show Gap Addresses',
            'Only With Amount'
          ],
          filterValues: []
        },
        utxos: {
          data: [],
          total: 0,
          sats: true
        },
        payment: {
          data: [{address: '', amount: undefined}],
          changeWallet: null,
          changeAddress: '',
          feeRate: 1,
          psbtBase64: '',
          utxoSelectionModes: [
            'Manual',
            'Random',
            'Smaller Inputs First',
            'Larger Inputs First'
          ],
          utxoSelectionMode: 'Manual',
          show: false,
          showAdvanced: false
        },
        mempool: {
          endpoint: ''
        },
        WalletsTable: {
          columns: [
            {
              name: 'title',
              align: 'left',
              label: 'Title',
              field: 'title'
            },
            {
              name: 'type',
              align: 'left',
              label: 'Type',
              field: 'type'
            },
            {name: 'id', align: 'left', label: 'ID', field: 'id'},
            {
              name: 'masterpub',
              align: 'left',
              label: 'MasterPub',
              field: 'masterpub'
            }
          ],
          pagination: {
            rowsPerPage: 10
          }
        },
        UtxoTable: {
          columns: [
            {
              name: 'expand',
              align: 'left',
              label: ''
            },
            {
              name: 'selected',
              align: 'left',
              label: ''
            },
            {
              name: 'status',
              align: 'center',
              label: 'Status',
              sortable: true
            },
            {
              name: 'address',
              align: 'left',
              label: 'Address',
              field: 'address',
              sortable: true
            },
            {
              name: 'amount',
              align: 'left',
              label: 'Amount',
              field: 'amount',
              sortable: true
            },
            {
              name: 'date',
              align: 'left',
              label: 'Date',
              field: 'date',
              sortable: true
            },
            {
              name: 'wallet',
              align: 'left',
              label: 'Account',
              field: 'wallet',
              sortable: true
            }
          ],
          pagination: {
            rowsPerPage: 10
          },
          uxtosFilter: ''
        },
        PaymentTable: {
          columns: [
            {
              name: 'data',
              align: 'left'
            }
          ],
          pagination: {
            rowsPerPage: 10
          }
        },
        AddressesTable: {
          columns: [
            {
              name: 'actions',
              align: 'left',
              label: '',
              field: 'actions'
            },
            {
              name: 'address',
              align: 'left',
              label: 'Address',
              field: 'address',
              sortable: true
            },
            {
              name: 'amount',
              align: 'left',
              label: 'Amount',
              field: 'amount',
              sortable: true
            },
            {
              name: 'note',
              align: 'left',
              label: 'Note',
              field: 'note',
              sortable: true
            },
            {
              name: 'wallet',
              align: 'left',
              label: 'Account',
              field: 'wallet',
              sortable: true
            }
          ],
          pagination: {
            rowsPerPage: 0,
            sortBy: 'amount',
            descending: true
          },
          addressesFilter: ''
        },

        HistoryTable: {
          columns: [
            {
              name: 'expand',
              align: 'left',
              label: ''
            },
            {
              name: 'status',
              align: 'left',
              label: 'Status'
            },
            {
              name: 'amount',
              align: 'left',
              label: 'Amount',
              field: 'amount',
              sortable: true
            },
            {
              name: 'address',
              align: 'left',
              label: 'Address',
              field: 'address',
              sortable: true
            },
            {
              name: 'date',
              align: 'left',
              label: 'Date',
              field: 'date',
              sortable: true
            }
          ],
          pagination: {
            rowsPerPage: 0,
            sortBy: 'date',
            descending: true
          },
          addressesFilter: ''
        },

        formDialog: {
          show: false,
          data: {}
        },

        qrCodeDialog: {
          show: false,
          data: null
        }
      }
    },

    methods: {
      getWalletName: function (walletId) {
        const wallet = this.walletLinks.find(wl => wl.id === walletId)
        return wallet ? wallet.title : 'unknown'
      },
      getFilteredAddresses: function () {
        const selectedWalletId = this.addresses.selectedWallet?.id
        const filter = this.addresses.filterValues || []
        const includeChangeAddrs = filter.includes('Show Change Addresses')
        const includeGapAddrs = filter.includes('Show Gap Addresses')
        const excludeNoAmount = filter.includes('Only With Amount')

        const walletsLimit = this.walletLinks.reduce((r, w) => {
          r[`_${w.id}`] = w.address_no
          return r
        }, {})

        const addresses = this.addresses.data.filter(
          a =>
            (includeChangeAddrs || a.branch_index === 0) &&
            (includeGapAddrs ||
              a.branch_index === 1 ||
              a.address_index <= walletsLimit[`_${a.wallet}`]) &&
            !(excludeNoAmount && a.amount === 0) &&
            (!selectedWalletId || a.wallet === selectedWalletId)
        )
        return addresses
      },
      deletePaymentAddress: function (v) {
        const index = this.payment.data.indexOf(v)
        if (index !== -1) {
          this.payment.data.splice(index, 1)
        }
      },
      initPaymentData: function () {
        console.log('### initPaymentData', this.payment.show)
        if (!this.payment.show) return

        this.payment.changeWallet = this.walletLinks[0]
        // temp solution
        const changeAddress = this.addresses.data.filter(
          a => a.wallet === this.payment.changeWallet.id
        )
        this.payment.changeAddress = changeAddress.pop().address
        this.payment.showAdvanced = false
      },
      addPaymentAddress: function () {
        this.payment.data.push({address: '', amount: undefined})
      },
      getTotalPaymentAmount: function () {
        const total = this.payment.data.reduce((t, a) => t + (a.amount || 0), 0)
        return this.satBtc(total)
      },
      getTotalUtxoAmount: function () {
        const total = this.utxos.data.reduce((t, a) => t + (a.amount || 0), 0)
        return this.satBtc(total)
      },
      createTransaction: async function () {
        const wallet = this.g.user.wallets[0] // todo: find active wallet
        try {
          const tx = {
            fee_rate: this.payment.feeRate,
            masterpubs: this.walletLinks.map(w => w.masterpub)
          }
          console.log('### this.utxos', this.utxos)
          tx.inputs = this.utxos.data
            .filter(utxo => utxo.selected)
            .map(utxo => ({
              txid: utxo.txId,
              vout: utxo.vout,
              amount: utxo.amount,
              address: utxo.address,
              branch_index: utxo.branch_index,
              address_index: utxo.address_index,
              master_fingerprint: utxo.master_fingerprint,
              txHex: ''
            }))
          tx.outputs = this.payment.data.map(out => ({
            address: out.address,
            amount: out.amount
          }))

          // change address
          // tx.outputs.push({
          //   address: 'bc1qs2ys7y4rksn7urgmu2nvzaxdc576uz95c6v480',
          //   amount: 0,
          //   branch_index: 0,
          //   address_index: 0,
          //   master_fingerprint: ''
          // })

          for (const input of tx.inputs) {
            input.tx_hex = await this.fetchTxHex(input.txid)
          }

          console.log('### psbt tx', tx)
          const {data} = await LNbits.api.request(
            'POST',
            '/watchonly/api/v1/psbt',
            wallet.adminkey,
            tx
          )

          console.log('### psbt response', data)
          this.payment.psbtBase64 = data
        } catch (err) {
          console.log('### err', err)
        }
      },
      getFilteredAddressesHistory: function () {
        console.log('### this.addresses.history', JSON.stringify(this.addresses.history))
        return this.addresses.history
          .filter(a => !a.isChange)
          .sort((a, b) => (!a.height ? -1 : b.height - a.height))
      },
      fetchTxHex: async function (txId, retryCount = 0) {
        const {
          bitcoin: {transactions: transactionsAPI}
        } = mempoolJS()
        try {
          return await transactionsAPI.getTxHex({txid: txId})
        } catch (err) {
          if (retryCount > 10) throw err
          await sleep((retryCount + 1) * 1000)
          return this.fetchTxHex(txId, retryCount + 1)
        }
      },
      showAddressHistoryDetails: function (addressHistory) {
        addressHistory.expanded = true
      },
      getAddressDetails: function (address) {
        LNbits.api
          .request(
            'GET',
            '/watchonly/api/v1/mempool/' + address,
            this.g.user.wallets[0].inkey
          )
          .then(function (response) {
            return reponse.data
          })
          .catch(function (error) {
            LNbits.utils.notifyApiError(error)
          })
      },
      refreshAddresses: async function () {
        const wallets = await this.getWatchOnlyWallets()
        this.addresses.data = []
        for (const {id, address_no} of wallets) {
          const addrs = await this.getAddressesForWallet(id)
          addrs.forEach(a => (a.expanded = false))
          this.addresses.data.push(...addrs)
        }
      },
      getAddressesForWallet: async function (walletId) {
        try {
          const {data} = await LNbits.api.request(
            'GET',
            '/watchonly/api/v1/addresses/' + walletId,
            this.g.user.wallets[0].inkey
          )
          return data
        } catch (err) {
          LNbits.utils.notifyApiError(err)
        }
      },
      updateAmountForAddress: async function (addressData, amount = 0) {
        try {
          const wallet = this.g.user.wallets[0] // todo: find active wallet
          addressData.amount = amount
          if (addressData.branch_index === 0) {
            const addressWallet = this.walletLinks.find(
              w => w.id === addressData.wallet
            )
            if (
              addressWallet &&
              addressWallet.address_no < addressData.address_index
            ) {
              addressWallet.address_no = addressData.address_index
            }
          }

          const {data} = await LNbits.api.request(
            'PUT',
            `/watchonly/api/v1/address/${addressData.id}`,
            wallet.adminkey,
            {amount}
          )
        } catch (err) {
          LNbits.utils.notifyApiError(err)
        }
      },
      updateNoteForAddress: async function (addressData, note) {
        try {
          const wallet = this.g.user.wallets[0] // todo: find active wallet
          addressData.note = note
          const {data} = await LNbits.api.request(
            'PUT',
            `/watchonly/api/v1/address/${addressData.id}`,
            wallet.adminkey,
            {note: addressData.note}
          )
        } catch (err) {
          LNbits.utils.notifyApiError(err)
        }
      },

      openGetFreshAddressDialog: async function (walletId) {
        const wallet = this.g.user.wallets[0] // todo: find active wallet
        const {data} = await LNbits.api.request(
          'GET',
          `/watchonly/api/v1/address/${walletId}`,
          this.g.user.wallets[0].inkey
        )
        this.openQrCodeDialog(data)
      },
      getMempool: function () {
        var self = this

        LNbits.api
          .request(
            'GET',
            '/watchonly/api/v1/mempool',
            this.g.user.wallets[0].adminkey
          )
          .then(function (response) {
            self.mempool.endpoint = response.data.endpoint
          })
          .catch(function (error) {
            LNbits.utils.notifyApiError(error)
          })
      },

      updateMempool: function () {
        var self = this
        var wallet = this.g.user.wallets[0]
        LNbits.api
          .request(
            'PUT',
            '/watchonly/api/v1/mempool',
            wallet.adminkey,
            self.mempool
          )
          .then(function (response) {
            self.mempool.endpoint = response.data.endpoint
            self.walletLinks.push(mapwalletLink(response.data))
          })
          .catch(function (error) {
            LNbits.utils.notifyApiError(error)
          })
      },
      addressHistoryFromTxs: function (addressData, txs) {
        const addressHistory = []
        txs.forEach(tx => {
          const sent = tx.vin
            .filter(
              vin => vin.prevout.scriptpubkey_address === addressData.address
            )
            .map(vin => ({
              sent: true,
              txId: tx.txid,
              address: addressData.address,
              isChange: addressData.branch_index === 1,
              amount: vin.prevout.value,
              date: blockTimeToDate(tx.status.block_time),
              height: tx.status.block_height,
              confirmed: tx.status.confirmed,
              fee: tx.fee,
              expanded: false
            }))
          const received = tx.vout
            .filter(vout => vout.scriptpubkey_address === addressData.address)
            .map(vout => ({
              received: true,
              txId: tx.txid,
              address: addressData.address,
              isChange: addressData.branch_index === 1,
              amount: vout.value,
              date: blockTimeToDate(tx.status.block_time),
              height: tx.status.block_height,
              confirmed: tx.status.confirmed,
              fee: tx.fee,
              expanded: false
            }))
          addressHistory.push(...sent, ...received)
        })
        return addressHistory
      },
      getAddressTxsDelayed: async function (addrData, retryCount = 0) {
        const {
          bitcoin: {addresses: addressesAPI}
        } = mempoolJS()
        try {
          await sleep(250)
          const addressTxs = await addressesAPI.getAddressTxs({
            address: addrData.address
          })
          return this.addressHistoryFromTxs(addrData, addressTxs)
        } catch (err) {
          if (retryCount > 10) throw err
          await sleep((retryCount + 1) * 1000)
          return this.getAddressTxsDelayed(addrData, retryCount + 1)
        }
      },
      getAddressTxsUtxoDelayed: async function (address, retryCount = 0) {
        const {
          bitcoin: {addresses: addressesAPI}
        } = mempoolJS()
        try {
          await sleep(250)
          return await addressesAPI.getAddressTxsUtxo({
            address
          })
        } catch (err) {
          if (retryCount > 10) throw err
          await sleep((retryCount + 1) * 1000)
          return this.getAddressTxsUtxoDelayed(address, retryCount + 1)
        }
      },
      updateUtxosForAddress: function (addressData, utxos = []) {
        console.log('### updateUtxosForAddress', utxos)
        const wallet =
          this.walletLinks.find(w => w.id === addressData.wallet) || {}
        utxos.forEach(utxo => {
          this.utxos.data.push({
            id: addressData.id,
            address: addressData.address,
            isChange: addressData.branch_index === 1,
            address_index: addressData.address_index,
            branch_index: addressData.branch_index,
            wallet: addressData.wallet,
            master_fingerprint: wallet.fingerprint,
            txId: utxo.txid,
            vout: utxo.vout,
            confirmed: utxo.status.confirmed,
            amount: utxo.value,
            date: blockTimeToDate(utxo.status?.block_time),
            sort: utxo.status?.block_time,
            expanded: false,
            selected: false
          })
        })
        if (utxos.length) {
          this.utxos.data.sort((a, b) => b.sort - a.sort)
          this.utxos.total = this.utxos.data.reduce(
            (total, y) => (total += y?.amount || 0),
            0
          )
        }
        const addressTotal = utxos.reduce(
          (total, y) => (total += y?.value || 0),
          0
        )
        this.updateAmountForAddress(addressData, addressTotal)
      },
      scanAllAddressUTXOs: async function () {
        await this.refreshAddresses()
        this.addresses.history = []
        let addresses = this.addresses.data
        this.utxos.data = []
        // Loop while new funds are found on the gap adresses.
        // Use 1000 limit as a safety check (scan 20 000 addresses max)
        for (let i = 0; i < 1000 && addresses.length; i++) {
          await this.updateUtxosForAddresses(addresses)
          const oldAddresses = this.addresses.data.slice()
          await this.refreshAddresses()
          const newAddresses = this.addresses.data.slice()
          // check if gap addresses have been extended
          addresses = newAddresses.filter(
            newAddr => !oldAddresses.find(oldAddr => oldAddr.id === newAddr.id)
          )
          if (addresses.length) {
            this.$q.notify({
              type: 'positive',
              message: 'Funds found! Scanning for more...',
              timeout: 10000
            })
          }
        }
      },
      scanAddressWithAmountUTXOs: async function () {
        const addresses = this.addresses.data.filter(a => a.has_activity) // todo: remove duplicates
        this.utxos.data = []
        await this.updateUtxosForAddresses(addresses)
      },
      updateUtxosForAddresses: async function (addresses = []) {
        this.scan = {scanning: true, scanCount: addresses.length, scanIndex: 0}

        try {
          for (addrData of addresses) {
            const addressHistory = await this.getAddressTxsDelayed(addrData)
            this.addresses.history.push(...addressHistory)
            if (addressHistory.length) {
              // only if it ever had any activity
              const utxos = await this.getAddressTxsUtxoDelayed(
                addrData.address
              )
              this.updateUtxosForAddress(addrData, utxos)
            }

            this.scan.scanIndex++
          }
        } catch (err) {
          console.error(err) // todo: show UI error
        } finally {
          this.scan.scanning = false
        }
      },

      getWatchOnlyWallets: async function () {
        const {data} = await LNbits.api.request(
          'GET',
          '/watchonly/api/v1/wallet',
          this.g.user.wallets[0].inkey
        )
        return data
      },
      refreshWalletLinks: async function () {
        try {
          const wallets = await this.getWatchOnlyWallets()
          this.walletLinks = wallets.map(w => mapWalletLink(w))
        } catch (err) {
          LNbits.utils.notifyApiError(err)
        }
      },

      closeFormDialog: function () {
        this.formDialog.data = {
          is_unique: false
        }
      },
      openQrCodeDialog: function (address) {
        this.currentAddress = address
        this.addresses.note = address.note || ''
        this.addresses.show = true
      },
      sendFormData: function () {
        var wallet = this.g.user.wallets[0]
        var data = _.omit(this.formDialog.data, 'wallet')
        this.createWalletLink(wallet, data)
      },
      createWalletLink: async function (wallet, data) {
        try {
          const response = await LNbits.api.request(
            'POST',
            '/watchonly/api/v1/wallet',
            wallet.adminkey,
            data
          )
          this.walletLinks.push(mapWalletLink(response.data))
          this.formDialog.show = false
          await this.refreshWalletLinks()
        } catch (error) {
          LNbits.utils.notifyApiError(error)
        }
      },
      deleteWalletLink: function (linkId) {
        var self = this
        var link = _.findWhere(this.walletLinks, {id: linkId})
        LNbits.utils
          .confirmDialog(
            'Are you sure you want to delete this watch only wallet?'
          )
          .onOk(async () => {
            try {
              await LNbits.api.request(
                'DELETE',
                '/watchonly/api/v1/wallet/' + linkId,
                this.g.user.wallets[0].adminkey
              )
              this.walletLinks = _.reject(this.walletLinks, function (obj) {
                return obj.id === linkId
              })
              await this.refreshWalletLinks()
              await this.refreshAddresses()
              await this.scanAddressWithAmountUTXOs()
            } catch (err) {
              LNbits.utils.notifyApiError(error)
            }
          })
      },
      exportCSV: function () {
        LNbits.utils.exportCSV(this.paywallsTable.columns, this.paywalls)
      },
      satBtc(val) {
        return this.utxos.sats
          ? LNbits.utils.formatSat(val)
          : val == 0
          ? 0.0
          : (val / 100000000).toFixed(8)
      }
    },
    created: async function () {
      if (this.g.user.wallets.length) {
        this.getMempool()
        await this.refreshWalletLinks()
        await this.refreshAddresses()
        await this.scanAddressWithAmountUTXOs()
      }
    }
  })
</script>
{% endblock %}
