{% extends "base.html" %} {% from "macros.jinja" import window_vars with context
%} {% block page %}
<div class="row q-col-gutter-md">
  <div class="col-12 col-md-7 q-gutter-y-md">
    <q-card>
      <q-card-section>
        {% raw %}
        <q-btn unelevated color="primary" @click="formDialog.show = true"
          >Add Wallet Account
        </q-btn>
        <q-btn unelevated color="primary" icon="edit">
          <div class="cursor-pointer">
            <q-tooltip> Point to another Mempool </q-tooltip>
            {{ this.mempool.endpoint }}
            <q-popup-edit v-model="mempool.endpoint">
              <q-input color="accent" v-model="mempool.endpoint"> </q-input>
              <center>
                <q-btn flat dense @click="updateMempool()" v-close-popup
                  >set</q-btn
                >
                <q-btn flat dense v-close-popup>cancel</q-btn>
              </center>
            </q-popup-edit>
          </div>
        </q-btn>
      </q-card-section>
    </q-card>

    <q-card>
      <q-card-section>
        <div class="row items-center no-wrap q-mb-md">
          <div class="col">
            <h5 class="text-subtitle1 q-my-none">Wallet Accounts</h5>
          </div>
          <div class="col-auto">
            <q-input
              borderless
              dense
              debounce="300"
              v-model="filter"
              placeholder="Search"
            >
              <template v-slot:append>
                <q-icon name="search"></q-icon>
              </template>
            </q-input>
          </div>
        </div>
        <q-table
          flat
          dense
          :data="walletLinks"
          row-key="id"
          :columns="WalletsTable.columns"
          :pagination.sync="WalletsTable.pagination"
          :filter="filter"
        >
          <template v-slot:header="props">
            <q-tr :props="props">
              <q-th auto-width></q-th>
              <q-th
                v-for="col in props.cols"
                :key="col.name"
                :props="props"
                auto-width
              >
                {{ col.label }}
              </q-th>
              <q-th auto-width></q-th>
            </q-tr>
          </template>
          <template v-slot:body="props">
            <q-tr :props="props">
              <q-td auto-width>
                <q-btn
                  flat
                  dense
                  size="xs"
                  @click="deleteWalletLink(props.row.id)"
                  icon="cancel"
                  color="pink"
                ></q-btn>
                <q-badge
                  color="secondary"
                  class="q-mr-md cursor-pointer"
                  @click="openGetFreshAddressDialog(props.row.id)"
                >
                  New Receive Address
                </q-badge>
              </q-td>
              <q-td
                v-for="col in props.cols"
                :key="col.name"
                :props="props"
                auto-width
              >
                {{ col.value }}
              </q-td>
            </q-tr>
          </template>
        </q-table>
      </q-card-section>
    </q-card>

    <q-card>
      <div class="row items-center no-wrap q-mb-md">
        <div class="col q-ml-lg">
          <q-btn
            unelevated
            color="secondary"
            @click="scanAllAddressUTXOs"
            :disabled="scan.scanning == true"
            >Scan Blockchain</q-btn
          >
          <q-spinner
            v-if="scan.scanning == true"
            color="primary"
            size="2.55em"
          ></q-spinner>
        </div>
        <div class="col">
          <div class="row justify-center q-gutter-x-md items-center">
            <div class="text-h3 q-pa-sm">{{satBtc(utxos.total)}}</div>
            <q-btn flat @click="utxos.sats = !utxos.sats">
              {{utxos.sats ? ' sats' : ' BTC'}}</q-btn
            >
          </div>
        </div>
      </div>
      <div v-if="scan.scanning == true">
        <!-- todo: make height smaller -->
        <q-linear-progress
          :value="scan.scanIndex / scan.scanCount"
          size="10px"
          color="primary"
          class="q-mt-sm"
        ></q-linear-progress>
      </div>
    </q-card>

    <q-card>
      <q-card-section>
        <q-tabs v-model="tab" no-caps class="bg-dark text-white shadow-2">
          <q-tab name="addresses" label="Addresses"></q-tab>
          <q-tab name="history" label="History"></q-tab>
          <q-tab name="coins" label="Coins"></q-tab>
        </q-tabs>
        <q-tab-panels v-model="tab">
          <!-- todo: why blak bacground? -->

          <q-tab-panel name="addresses">
            <div class="row items-center no-wrap q-mb-md">
              <div class="col q-pr-lg">
                <q-select
                  filled
                  clearable
                  dense
                  emit-value
                  v-model="addresses.selectedWallet"
                  :options="walletLinks"
                  label="Wallet Account"
                ></q-select>
              </div>
              <div class="col q-pr-lg">
                <q-select
                  filled
                  clearable
                  dense
                  emit-value
                  multiple
                  :options="addresses.filterOptions"
                  v-model="addresses.filterValues"
                  :options="walletLinks"
                  label="Filter"
                ></q-select>
              </div>
              <div class="col-auto">
                <q-input
                  borderless
                  dense
                  debounce="300"
                  v-model="AddressesTable.filter"
                  placeholder="Search"
                >
                  <template v-slot:append>
                    <q-icon name="search"></q-icon>
                  </template>
                </q-input>
              </div>
            </div>
            <q-table
              style="height: 400px"
              flat
              dense
              :data="getFilteredAddresses()"
              row-key="id"
              virtual-scroll
              :columns="AddressesTable.columns"
              :pagination.sync="AddressesTable.pagination"
              :filter="AddressesTable.filter"
            >
              <template v-slot:body-cell-actions="props">
                <q-td :props="props">
                  <div class="row">
                    <div class="cell">
                      <q-btn
                        unelevated
                        dense
                        size="sm"
                        icon="qr_code"
                        :color="($q.dark.isActive) ? 'grey-7' : 'grey-5'"
                        @click="openQrCodeDialog(props.row)"
                      ></q-btn>
                    </div>
                    <div class="cell">
                      <q-btn
                        v-if="props.row.amount"
                        flat
                        dense
                        size="sm"
                        icon="launch"
                        type="a"
                        :href="mempool.endpoint + '/address/' + props.row.address"
                        target="_blank"
                      ></q-btn>
                    </div>
                  </div>
                </q-td>
              </template>
              <template v-slot:body-cell-wallet="props">
                <q-td :props="props">
                  <div>{{ getWalletName(props.row.wallet) }}</div>
                </q-td>
              </template>
              <template v-slot:body-cell-amount="props">
                <q-td
                  :props="props"
                  :class="props.row.amount > 0 ? 'text-green-13 text-weight-bold' : ''"
                >
                  <div>{{satBtc(props.row.amount)}}</div>
                </q-td>
              </template>
              <template v-slot:body-cell-address="props">
                <q-td :props="props">
                  <div>
                    {{props.row.address}}
                    <q-badge
                      v-if="props.row.branch_index === 1"
                      color="orange"
                      class="q-mr-md"
                    >
                      change
                    </q-badge>
                  </div>
                </q-td>
              </template>
            </q-table>
          </q-tab-panel>
          <q-tab-panel name="history">
            <div class="row items-center no-wrap q-mb-md">
              <div class="col q-pr-lg"></div>
              <div class="col q-pr-lg"></div>
              <div class="col-auto">
                <q-input
                  borderless
                  dense
                  debounce="300"
                  v-model="HistoryTable.filter"
                  placeholder="Search"
                >
                  <template v-slot:append>
                    <q-icon name="search"></q-icon>
                  </template>
                </q-input>
              </div>
            </div>
            <q-table
              style="height: 400px"
              flat
              dense
              :data="getFilteredAddressesHistory()"
              row-key="id"
              virtual-scroll
              :columns="HistoryTable.columns"
              :pagination.sync="HistoryTable.pagination"
              :filter="HistoryTable.filter"
            >
              <template v-slot:body="props">
                <q-tr :props="props">
                  <q-td auto-width>
                    <q-btn
                      size="sm"
                      color="accent"
                      round
                      dense
                      @click="props.row.expanded = !props.row.expanded"
                      :icon="props.row.expanded ? 'remove' : 'add'"
                    />
                  </q-td>

                  <q-td key="status" :props="props">
                    <q-badge
                      v-if="props.row.sent"
                      color="orange"
                      class="q-mr-md"
                    >
                      {{props.row.confirmed ? 'Sent' : 'Sending...'}}
                    </q-badge>
                    <q-badge
                      v-if="props.row.received"
                      color="green"
                      class="q-mr-md"
                    >
                      {{props.row.confirmed ? 'Received' : 'Receiving...'}}
                    </q-badge>
                  </q-td>
                  <q-td
                    key="amount"
                    :props="props"
                    :class="props.row.amount && props.row.received > 0 ? 'text-green-13 text-weight-bold' : ''"
                  >
                    <div>{{satBtc(props.row.amount)}}</div>
                  </q-td>
                  <q-td key="address" :props="props">
                    {{ props.row.address }}
                  </q-td>
                  <q-td key="date" :props="props"> {{ props.row.date }} </q-td>
                </q-tr>
                <q-tr v-show="props.row.expanded" :props="props">
                  <q-td colspan="100%">
                    <div class="row items-center no-wrap q-mb-md">
                      <div class="col-2 q-pr-lg text-weight-bold">
                        Transaction Id
                      </div>
                      <div class="col-10 q-pr-lg">{{props.row.txId}}</div>
                    </div>
                    <div class="row items-center no-wrap q-mb-md">
                      <div class="col-2 q-pr-lg text-weight-bold">Fee</div>
                      <div class="col-4 q-pr-lg">{{satBtc(props.row.fee)}}</div>
                    </div>
                  </q-td>
                </q-tr>
              </template>
            </q-table>
          </q-tab-panel>
          <q-tab-panel name="coins">
            <div class="row items-center no-wrap q-mb-md">
              <div class="col">
                <h5 class="text-subtitle1 q-my-none">UTXOs</h5>
              </div>
              <div class="col-auto">
                <q-input
                  borderless
                  dense
                  debounce="300"
                  v-model="UtxoTable.filter"
                  placeholder="Search"
                >
                  <template v-slot:append>
                    <q-icon name="search"></q-icon>
                  </template>
                </q-input>
              </div>
            </div>
            <q-table
              flat
              dense
              :data="utxos.data"
              row-key="txid"
              :columns="UtxoTable.columns"
              :pagination.sync="UtxoTable.pagination"
              :filter="UtxoTable.filter"
            >
              <template v-slot:header="props">
                <q-tr :props="props">
                  <q-th
                    v-for="col in props.cols"
                    :key="col.name"
                    :props="props"
                    auto-width
                  >
                    {{ col.label }}
                  </q-th>
                  <q-th auto-width></q-th>
                </q-tr>
              </template>
              <template v-slot:body="props">
                <q-tr :props="props">
                  <q-td
                    v-for="col in props.cols"
                    :key="col.name"
                    :props="props"
                    auto-width
                    :class="col.value == true ? 'text-green-13 text-weight-bold' : ''"
                  >
                    {{ col.name == 'value' ? satBtc(col.value) : col.value }}
                  </q-td>
                </q-tr>
              </template>
            </q-table>
          </q-tab-panel>
        </q-tab-panels>
      </q-card-section>
    </q-card>
  </div>

  {% endraw %}

  <div class="col-12 col-md-5 q-gutter-y-md">
    <q-card>
      <q-card-section>
        <h6 class="text-subtitle1 q-my-none">
          {{SITE_TITLE}} Watch Only Extension
        </h6>
      </q-card-section>
      <q-card-section class="q-pa-none">
        <q-separator></q-separator>
        <q-list> {% include "watchonly/_api_docs.html" %} </q-list>
      </q-card-section>
    </q-card>
  </div>

  <q-dialog v-model="formDialog.show" position="top" @hide="closeFormDialog">
    <q-card class="q-pa-lg q-pt-xl lnbits__dialog-card">
      <q-form @submit="sendFormData" class="q-gutter-md">
        <q-input
          filled
          dense
          v-model.trim="formDialog.data.title"
          type="text"
          label="Title"
        ></q-input>

        <q-input
          filled
          type="textarea"
          v-model="formDialog.data.masterpub"
          height="50px"
          autogrow
          label="Account Extended Public Key; xpub, ypub, zpub; Bitcoin Descriptor"
        ></q-input>

        <div class="row q-mt-lg">
          <q-btn
            unelevated
            color="primary"
            :disable="
                formDialog.data.masterpub == null ||
                formDialog.data.title == null"
            type="submit"
            >Add Watch-only Account</q-btn
          >
          <q-btn v-close-popup flat color="grey" class="q-ml-auto"
            >Cancel</q-btn
          >
        </div>
      </q-form>
    </q-card>
  </q-dialog>

  <q-dialog v-model="addresses.show" position="top">
    <q-card v-if="addresses.data" class="q-pa-lg lnbits__dialog-card">
      {% raw %}

      <h5 class="text-subtitle1 q-my-none">Address Details</h5>
      <q-separator></q-separator><br />

      <q-responsive :ratio="1" class="q-mx-xl q-mb-md">
        <qrcode
          v-if="currentAddress"
          :value="currentAddress.address"
          :options="{width: 800}"
          class="rounded-borders"
        ></qrcode>
      </q-responsive>
      <p v-if="currentAddress">
        {{ currentAddress.address }}
        <q-btn
          flat
          dense
          size="ms"
          icon="launch"
          type="a"
          :href="mempool.endpoint + '/address/' + currentAddress.address"
          target="_blank"
        ></q-btn>
      </p>
      <p v-if="currentAddress">
        <q-input
          filled
          dense
          v-model.trim="addresses.note"
          type="text"
          label="Note"
        ></q-input>
      </p>
      <div class="row q-mt-lg q-gutter-sm">
        <q-btn
          v-if="currentAddress"
          outline
          v-close-popup
          color="grey"
          @click="updateNoteForAddress(currentAddress)"
          class="q-ml-sm"
          >Update Note</q-btn
        >
        <q-btn v-close-popup flat color="grey" class="q-ml-auto">Close</q-btn>
      </div>
    </q-card>
  </q-dialog>
  {% endraw %}
</div>
{% endblock %} {% block scripts %} {{ window_vars(user) }}
<script type="text/javascript" src="https://mempool.space/mempool.js"></script>
<style></style>
<script>
  const sleep = ms => new Promise(r => setTimeout(r, ms))

  Vue.component(VueQrcode.name, VueQrcode)

  Vue.filter('reverse', function (value) {
    // slice to make a copy of array, then reverse the copy
    return value.slice().reverse()
  })
  var locationPath = [
    window.location.protocol,
    '//',
    window.location.hostname,
    window.location.pathname
  ].join('')

  var mapWalletLink = function (obj) {
    obj._data = _.clone(obj)
    obj.date = obj.time
      ? Quasar.utils.date.formatDate(
          new Date(obj.time * 1000),
          'YYYY-MM-DD HH:mm'
        )
      : ''
    const mP = obj.masterpub || ''
    obj.label = `${obj.title} - ${mP.substring(0, 10)}...${mP.slice(-10)}`
    return obj
  }

  const blockTimeToDate = blockTime =>
    blockTime ? moment(blockTime * 1000).format('LLL') : ''

  var mapAddresses = function (obj) {
    obj._data = _.clone(obj)
    obj.date = obj.time
      ? Quasar.utils.date.formatDate(
          new Date(obj.time * 1000),
          'YYYY-MM-DD HH:mm'
        )
      : ''
    return obj
  }

  new Vue({
    el: '#vue',
    mixins: [windowMixin],
    data: function () {
      return {
        filter: '',
        balance: null,
        scan: {
          scanning: false,
          scanCount: 0,
          scanIndex: 0
        },

        walletLinks: [],

        currentAddress: null,

        tab: 'addresses',
        addresses: {
          show: false,
          data: [],
          history: [],
          selectedWallet: null,
          note: '',
          filterOptions: [
            'Show Change Addresses',
            'Show Gap Addresses',
            'Only With Amount'
          ],
          filterValues: []
        },
        utxos: {
          data: [],
          total: 0,
          sats: true
        },
        mempool: {
          endpoint: ''
        },
        WalletsTable: {
          columns: [
            {
              name: 'title',
              align: 'left',
              label: 'Title',
              field: 'title'
            },
            {
              name: 'type',
              align: 'left',
              label: 'Type',
              field: 'type'
            },
            {name: 'id', align: 'left', label: 'ID', field: 'id'},
            {
              name: 'masterpub',
              align: 'left',
              label: 'MasterPub',
              field: 'masterpub'
            }
          ],
          pagination: {
            rowsPerPage: 10
          }
        },
        UtxoTable: {
          columns: [
            {
              name: 'confirmed',
              align: 'center',
              label: 'Confirmed',
              field: 'confirmed',
              sortable: true
            },
            {
              name: 'address',
              align: 'left',
              label: 'Address',
              field: 'address',
              sortable: true
            },
            {
              name: 'value',
              align: 'left',
              label: 'Value',
              field: 'value',
              sortable: true
            },
            {
              name: 'date',
              align: 'left',
              label: 'Date',
              field: 'date',
              sortable: true
            },
            {
              name: 'txid',
              align: 'left',
              label: 'TX ID',
              field: 'txid',
              sortable: true
            }
          ],
          pagination: {
            rowsPerPage: 10
          },
          uxtosFilter: ''
        },
        AddressesTable: {
          columns: [
            {
              name: 'actions',
              align: 'left',
              label: '',
              field: 'actions'
            },
            {
              name: 'address',
              align: 'left',
              label: 'Address',
              field: 'address',
              sortable: true
            },
            {
              name: 'amount',
              align: 'left',
              label: 'Amount',
              field: 'amount',
              sortable: true
            },
            {
              name: 'note',
              align: 'left',
              label: 'Note',
              field: 'note',
              sortable: true
            },
            {
              name: 'wallet',
              align: 'left',
              label: 'Wallet',
              field: 'wallet',
              sortable: true
            }
          ],
          pagination: {
            rowsPerPage: 0,
            sortBy: 'amount',
            descending: true
          },
          addressesFilter: ''
        },

        HistoryTable: {
          columns: [
            {
              name: 'expand',
              align: 'left',
              label: ''
            },
            {
              name: 'status',
              align: 'left',
              label: 'Status'
            },
            {
              name: 'amount',
              align: 'left',
              label: 'Amount',
              field: 'amount',
              sortable: true
            },
            {
              name: 'address',
              align: 'left',
              label: 'Address',
              field: 'address',
              sortable: true
            },
            {
              name: 'date',
              align: 'left',
              label: 'Date',
              field: 'date',
              sortable: true
            }
          ],
          pagination: {
            rowsPerPage: 0,
            sortBy: 'date',
            descending: true
          },
          addressesFilter: ''
        },

        formDialog: {
          show: false,
          data: {}
        },

        qrCodeDialog: {
          show: false,
          data: null
        }
      }
    },

    methods: {
      getWalletName: function (walletId) {
        const wallet = this.walletLinks.find(wl => wl.id === walletId)
        return wallet ? wallet.title : 'unknown'
      },
      getFilteredAddresses: function () {
        const selectedWalletId = this.addresses.selectedWallet?.id
        const filter = this.addresses.filterValues || []
        const includeChangeAddrs = filter.includes('Show Change Addresses')
        const includeGapAddrs = filter.includes('Show Gap Addresses')
        const excludeNoAmount = filter.includes('Only With Amount')

        const walletsLimit = this.walletLinks.reduce((r, w) => {
          r[`_${w.id}`] = w.address_no
          return r
        }, {})

        const addresses = this.addresses.data.filter(
          a =>
            (includeChangeAddrs || a.branch_index === 0) &&
            (includeGapAddrs ||
              a.branch_index === 1 ||
              a.address_index <= walletsLimit[`_${a.wallet}`]) &&
            !(excludeNoAmount && a.amount === 0) &&
            (!selectedWalletId || a.wallet === selectedWalletId)
        )
        return addresses
      },

      getFilteredAddressesHistory: function() {
        return this.addresses.history.filter(a => !a.isChange)
      },
      showAddressHistoryDetails: function (addressHistory) {
        addressHistory.expanded = true
      },
      getAddressDetails: function (address) {
        LNbits.api
          .request(
            'GET',
            '/watchonly/api/v1/mempool/' + address,
            this.g.user.wallets[0].inkey
          )
          .then(function (response) {
            return reponse.data
          })
          .catch(function (error) {
            LNbits.utils.notifyApiError(error)
          })
      },
      refreshAddresses: async function () {
        const wallets = await this.getWatchOnlyWallets()
        this.addresses.data = []
        for (const {id, address_no} of wallets) {
          const addrs = await this.getAddressesForWallet(id)
          this.addresses.data.push(...addrs)
        }
        console.log('### refreshAddresses', this.addresses.data)
      },
      getAddressesForWallet: async function (walletId) {
        try {
          const {data} = await LNbits.api.request(
            'GET',
            '/watchonly/api/v1/addresses/' + walletId,
            this.g.user.wallets[0].inkey
          )
          return data
        } catch (err) {
          LNbits.utils.notifyApiError(err)
        }
      },
      updateAmountForAddress: async function (addressId, amount = 0) {
        try {
          const wallet = this.g.user.wallets[0] // todo: find active wallet
          const {data} = await LNbits.api.request(
            'PUT',
            `/watchonly/api/v1/address/${addressId}`,
            wallet.adminkey,
            {amount}
          )
        } catch (err) {
          LNbits.utils.notifyApiError(err)
        }
      },
      updateNoteForAddress: async function (addressData) {
        try {
          const wallet = this.g.user.wallets[0] // todo: find active wallet
          addressData.note = this.addresses.note
          const {data} = await LNbits.api.request(
            'PUT',
            `/watchonly/api/v1/address/${addressData.id}`,
            wallet.adminkey,
            {note: addressData.note}
          )
        } catch (err) {
          LNbits.utils.notifyApiError(err)
        }
      },

      openGetFreshAddressDialog: async function (walletId) {
        const wallet = this.g.user.wallets[0] // todo: find active wallet
        const {data} = await LNbits.api.request(
          'GET',
          `/watchonly/api/v1/address/${walletId}`,
          this.g.user.wallets[0].inkey
        )
        this.openQrCodeDialog(data)
      },
      getMempool: function () {
        var self = this

        LNbits.api
          .request(
            'GET',
            '/watchonly/api/v1/mempool',
            this.g.user.wallets[0].adminkey
          )
          .then(function (response) {
            self.mempool.endpoint = response.data.endpoint
          })
          .catch(function (error) {
            LNbits.utils.notifyApiError(error)
          })
      },

      updateMempool: function () {
        var self = this
        var wallet = this.g.user.wallets[0]
        LNbits.api
          .request(
            'PUT',
            '/watchonly/api/v1/mempool',
            wallet.adminkey,
            self.mempool
          )
          .then(function (response) {
            self.mempool.endpoint = response.data.endpoint
            self.walletLinks.push(mapwalletLink(response.data))
          })
          .catch(function (error) {
            LNbits.utils.notifyApiError(error)
          })
      },
      addressHistoryFromTxs: function (addressData, txs) {
        const addressHistory = []
        txs.forEach(tx => {
          const sent = tx.vin
            .filter(vin => vin.prevout.scriptpubkey_address === addressData.address)
            .map(vin => ({
              sent: true,
              txId: tx.txid,
              address: addressData.address,
              isChange: addressData.branch_index === 1,
              amount: vin.prevout.value,
              date: blockTimeToDate(tx.status.block_time),
              confirmed: tx.status.confirmed,
              fee: tx.fee,
              expanded: false
            }))
          const received = tx.vout
            .filter(vout => vout.scriptpubkey_address === addressData.address)
            .map(vout => ({
              received: true,
              txId: tx.txid,
              address: addressData.address,
              isChange: addressData.branch_index === 1,
              amount: vout.value,
              date: blockTimeToDate(tx.status.block_time),
              confirmed: tx.status.confirmed,
              fee: tx.fee,
              expanded: false
            }))
          addressHistory.push(...sent, ...received)
        })
        return addressHistory
      },
      getAddressTxsDelayed: async function (addrData, retryCount = 0) {
        const {
          bitcoin: {addresses: addressesAPI}
        } = mempoolJS()
        try {
          console.log('### IN address tx call', addrData.address)
          await sleep(250)
          const addressTxs = await addressesAPI.getAddressTxs({address: addrData.address})
          return this.addressHistoryFromTxs(addrData, addressTxs)
        } catch (err) {
          console.log('### err tx call ', err)
          if (retryCount > 10) throw err
          await sleep((retryCount + 1) * 1000)
          return this.getAddressTxsDelayed(addrData, retryCount + 1)
        }
      },
      getAddressTxsUtxoDelayed: async function (address, retryCount = 0) {
        const {
          bitcoin: {addresses: addressesAPI}
        } = mempoolJS()
        try {
          console.log('### IN utxo tx call', address)
          await sleep(250)
          return await addressesAPI.getAddressTxsUtxo({
            address
          })
        } catch (err) {
          if (retryCount > 10) throw err
          console.log('### ERR utxo call', (retryCount + 1) * 1000, address)
          await sleep((retryCount + 1) * 1000)
          return this.getAddressTxsUtxoDelayed(address, retryCount + 1)
        }
      },
      updateUtxosForAddress: function (addressData, utxos = []) {
        utxos.forEach(utxo => {
          this.utxos.data.push({
            txid: utxo.txid,
            address: addressData.address,
            confirmed: utxo.status.confirmed,
            value: utxo.value,
            date: blockTimeToDate(utxo.status?.block_time),
            sort: utxo.status?.block_time
          })
        })
        if (utxos.length) {
          this.utxos.data.sort((a, b) => b.sort - a.sort)
          this.utxos.total = this.utxos.data.reduce(
            (total, y) => (total += y?.value || 0),
            0
          )
        }
        const addressTotal = utxos.reduce(
          (total, y) => (total += y?.value || 0),
          0
        )
        this.updateAmountForAddress(addressData.id, addressTotal)
      },
      scanAllAddressUTXOs: async function () {
        await this.refreshAddresses()
        this.addresses.history = []
        let addresses = this.addresses.data
        this.utxos.data = []
        // Loop while new funds are found on the gap adresses.
        // Use 1000 limit as a safety check (scan 20 000 addresses max)
        for (let i = 0; i < 1000 && addresses.length; i++) {
          await this.updateUtxosForAddresses(addresses)
          const oldAddresses = this.addresses.data.slice()
          await this.refreshAddresses()
          const newAddresses = this.addresses.data.slice()
          // check if gap addresses have been extended
          addresses = newAddresses.filter(
            newAddr => !oldAddresses.find(oldAddr => oldAddr.id === newAddr.id)
          )
          if (addresses.length) {
            this.$q.notify({
              type: 'positive',
              message: 'Funds found! Scanning for more...',
              timeout: 10000
            })
          }
          console.log('### this.addresses.history', this.addresses.history)
        }
      },
      scanAddressWithAmountUTXOs: async function () {
        const addresses = this.addresses.data.filter(a => a.has_activity) // todo: remove duplicates
        this.utxos.data = []
        await this.updateUtxosForAddresses(addresses)
      },
      updateUtxosForAddresses: async function (addresses = []) {
        this.scan = {scanning: true, scanCount: addresses.length, scanIndex: 0}

        try {
          for (addrData of addresses) {
            const addressHistory = await this.getAddressTxsDelayed(
              addrData
            )
            console.log('### addressHistory', addressHistory)
            this.addresses.history.push(...addressHistory)
            if (addressHistory.length) {
              // only if it ever had any activity
              const utxos = await this.getAddressTxsUtxoDelayed(
                addrData.address
              )
              this.updateUtxosForAddress(addrData, utxos)
            }

            this.scan.scanIndex++
          }
        } catch (err) {
          console.error(err) // todo: show UI error
        } finally {
          this.scan.scanning = false
        }
      },

      getWatchOnlyWallets: async function () {
        const {data} = await LNbits.api.request(
          'GET',
          '/watchonly/api/v1/wallet',
          this.g.user.wallets[0].inkey
        )
        return data
      },
      refreshWalletLinks: async function () {
        try {
          const wallets = await this.getWatchOnlyWallets()
          this.walletLinks = wallets.map(obj => {
            this.getAddressesForWallet(obj.id)
            return mapWalletLink(obj)
          })
        } catch (err) {
          console.log('### err', err)
          LNbits.utils.notifyApiError(err)
        }
      },

      closeFormDialog: function () {
        this.formDialog.data = {
          is_unique: false
        }
      },
      openQrCodeDialog: function (address) {
        this.currentAddress = address
        this.addresses.note = address.note || ''
        this.addresses.show = true
      },
      sendFormData: function () {
        var wallet = this.g.user.wallets[0]
        var data = _.omit(this.formDialog.data, 'wallet')
        this.createWalletLink(wallet, data)
      },
      createWalletLink: function (wallet, data) {
        var self = this

        LNbits.api
          .request('POST', '/watchonly/api/v1/wallet', wallet.adminkey, data)
          .then(function (response) {
            self.walletLinks.push(mapWalletLink(response.data))
            self.formDialog.show = false
          })
          .catch(function (error) {
            LNbits.utils.notifyApiError(error)
          })
      },
      deleteWalletLink: function (linkId) {
        console.log('### this.walletLinks', this.walletLinks)
        console.log('### addresses.filterValues', this.addresses.filterValues)

        var self = this
        var link = _.findWhere(this.walletLinks, {id: linkId})
        LNbits.utils
          .confirmDialog(
            'Are you sure you want to delete this watch only wallet?'
          )
          .onOk(async () => {
            try {
              await LNbits.api.request(
                'DELETE',
                '/watchonly/api/v1/wallet/' + linkId,
                this.g.user.wallets[0].adminkey
              )
              this.walletLinks = _.reject(this.walletLinks, function (obj) {
                return obj.id === linkId
              })
              await this.refreshAddresses()
              await this.scanAddressWithAmountUTXOs()
            } catch (err) {
              LNbits.utils.notifyApiError(error)
            }
          })
      },
      exportCSV: function () {
        LNbits.utils.exportCSV(this.paywallsTable.columns, this.paywalls)
      },
      satBtc(val) {
        return this.utxos.sats
          ? LNbits.utils.formatSat(val)
          : val == 0
          ? 0.0
          : (val / 100000000).toFixed(8)
      }
    },
    created: async function () {
      if (this.g.user.wallets.length) {
        this.getMempool()
        await this.refreshAddresses()
        await this.scanAddressWithAmountUTXOs()
        this.refreshWalletLinks()
      }
    }
  })
</script>
{% endblock %}
